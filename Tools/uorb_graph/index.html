<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>

.links line {
    /*stroke: #999; */
    stroke-opacity: 0.6;
}

.nodes circle {
    stroke: #fff;
    stroke-width: 1.5px;
}

</style>
</head>

<body>
<input id="search" type="text" autofocus>
Preset: <select id ="select-graph" name="select-graph" onchange="reloadSimulation(this.value);">
    <option value='graph_v4.json'>FMUv4</option>
    <option value='graph_sitl.json'>SITL</option>
    <option value='graph_full.json'>Full</option>
</select>
<br/>
<svg width="1200" height="1200"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var graph_option = document.getElementById("select-graph");
var default_json_file = graph_option.value;


/* search field: highlight all matching nodes on text change */
var preventFading = false;
function searchTextChanged() {
    var textField = document.getElementById("search");
    var searchText = textField.value;
    var opacity = 0.1;
    if (searchText == "" || document.activeElement != textField) {
        opacity = 1;
        preventFading = false;
    } else {
        preventFading = true;
    }

    /* change opacity */
    node.style("stroke-opacity", function(o) {
        thisOpacity = o.name.includes(searchText) ? 1 : opacity;
        this.setAttribute('fill-opacity', thisOpacity);
        return thisOpacity;
    });

    text.style("stroke-opacity", function(o) {
        thisOpacity = o.name.includes(searchText) ? 1 : opacity;
        this.setAttribute('fill-opacity', thisOpacity);
        return thisOpacity;
    });
    link.style("stroke-opacity", function(o) {
        return opacity;
    });
}
document.getElementById("search").addEventListener("keyup", searchTextChanged);
document.getElementById("search").addEventListener("focusout", searchTextChanged);
document.getElementById("search").addEventListener("focusin", searchTextChanged);



var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height"),
    font_size = 80; // font size in %


var collisionForce = rectCollide()
    .size(function (d) { return [d.width, d.height+3] })

var boxForce = boundedBox()
    .bounds([[0, 0], [width, height]])
    .size(function (d) { return [d.width, d.height] })

var simulation = d3.forceSimulation()
    .velocityDecay(0.2) // default: 0.4
    // alpha: initially 1, then reduced at each step, reducing the forces, so
    // that the simulation comes to a stop eventually
    .alphaMin(0.001) // default: 0.001
    .alphaDecay(0.0428) // default: 0.0228
    //.alphaTarget(1) // enabling this will make sure the simulation never comes
    // to a stop (and the nodes will keep fighting for their position)
    .force("link", d3.forceLink().id(function(d) { return d.id; })
    .distance(70)//.strength(0.02) // default: 30, 1 / Math.min(count(link.source), count(link.target));
        // distance: desired link distance
//      .iterations(1) // default: 1, greater = increased rigidity
    )
    .force("charge", d3.forceManyBody().strength(-350)) // decrease to make the
           // graph spread more (distance has a similar effect, but affects the
           // leaf nodes more)
    .force('box', boxForce) // keep the nodes inside the visible area
    .force('collision', collisionForce)
    .force("center", d3.forceCenter(width / 2, height / 2));

// SVG elements
var node = null;
var text = null;
var link = null;

function loadSimulation(json_file_name) {

    d3.json(json_file_name, function(error, graph) {
        if (error) throw error;

        link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line")
            .attr("stroke", function(d) { return d.color; })
            .style("stroke-dasharray", function(d) {
                if (d.style == "dashed") return "3, 3";
                return "1, 0";
            })
        ;

        var g = svg.append("g").selectAll("g").data(graph.nodes).enter().append("g");
        node = g.append("rect");
        text = g.append("text")
            .attr("class", "labels")
            .attr("font-size", font_size+"%")
            .attr("fill", function(d) { return "#fff"; })
            .attr("dy", ".35em")
            .attr("text-anchor", "middle")
            .text(function(d) { return d.name })
            .on("mouseover", fadeAnimated(.1))
            .on("mouseout", fadeAnimated(1))
            .on("dblclick", openLink);

        var paddingLeftRight = 18; // adjust the padding values depending on font and font size
        var paddingTopBottom = 5;

        svg.selectAll("text").each(function(d, i) {
            // get bounding box of text field and store it
            graph.nodes[i].width = this.getBBox().width+paddingLeftRight;
            graph.nodes[i].height = this.getBBox().height+paddingTopBottom;

            graph.nodes[i].vx = 0;
            graph.nodes[i].vy = 0;
        });


        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graph.links);

        function ticked() {
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            text
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y; });

            svg.selectAll("rect")
                .attr("x", function(d) { return d.x - d.width/2; })
                .attr("y", function(d) { return d.y - d.height/2;  })
                .attr("width", function(d) { return d.width; })
                .attr("height", function(d) { return d.height; })
                .attr("fill", function(d) { return d.color; });
        }

        // open the 'node.url' attribute in a new tab, if it exists
        function openLink(n) {
            if (typeof n.url !== 'undefined') {
                window.open(n.url, '_blank');
            }
        }


        // smooth fade in/out
        var animationTimer = null;
        var currentOpacity = 1;
        var destOpacity = 1;
        function fadeAnimated(opacity) {
            return function(d) {
                if (preventFading) return;

                if (animationTimer != null)
                    animationTimer.stop();

                destOpacity = opacity;

                animationTimer = d3.interval(function(elapsed) {
                    var newOpacity = currentOpacity + (destOpacity-currentOpacity) * elapsed/300;
                    // check if we overshot the destination opacity
                    if ((currentOpacity - destOpacity) * (newOpacity - destOpacity) < 0) {
                        currentOpacity = destOpacity;
                    } else {
                        currentOpacity = newOpacity;
                    }
                    fade(currentOpacity)(d);
                    if (Math.abs(currentOpacity - destOpacity) < 0.005) {
                        animationTimer.stop();
                        animationTimer = null;
                    }
                }, 30);
            }
        }

        // mouse over functionality: fade the rest of the graph

        var linkedByIndex = {};
        graph.links.forEach(function(d) {
            linkedByIndex[d.source.index + "," + d.target.index] = 1;
        });
        function isConnected(a, b) {
            return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
        }
        function fade(opacity) {
            return function(d) {
                node.style("stroke-opacity", function(o) {
                    thisOpacity = isConnected(d, o) ? 1 : opacity;
                    this.setAttribute('fill-opacity', thisOpacity);
                    return thisOpacity;
                });

                text.style("stroke-opacity", function(o) {
                    thisOpacity = isConnected(d, o) ? 1 : opacity;
                    this.setAttribute('fill-opacity', thisOpacity);
                    return thisOpacity;
                });

                link.style("stroke-opacity", function(o) {
                    return o.source === d || o.target === d ? 1 : opacity;
                });
            };
        }

    });
}

function reloadSimulation(json_file_name) {
    console.log(json_file_name);
    d3.selectAll("svg > *").remove();
    loadSimulation(json_file_name);
    simulation.alpha(1).restart();
}

/* initial graph */
loadSimulation(default_json_file);


function rectCollide() {
    var nodes, sizes, masses;
    var size = constant([0, 0]);
    var strength = 5;
    var iterations = 2;

    function force() {
        var node, size, mass, xi, yi;
        var i = -1;
        while (++i < iterations) { iterate(); }

        function iterate() {
            var j = -1;
            var tree = d3.quadtree(nodes, xCenter, yCenter).visitAfter(prepare);

            while (++j < nodes.length) {
                node = nodes[j];
                size = sizes[j];
                mass = masses[j];
                xi = xCenter(node);
                yi = yCenter(node);

                tree.visit(apply);
            }
        }

        function apply(quad, x0, y0, x1, y1) {
            var data = quad.data;
            var xSize = (size[0] + quad.size[0]) / 2;
            var ySize = (size[1] + quad.size[1]) / 2;
            if (data) {
                if (data.index <= node.index) { return; }

                var x = xi - xCenter(data);
                var y = yi - yCenter(data);
                var xd = Math.abs(x) - xSize;
                var yd = Math.abs(y) - ySize;

                if (xd < 0 && yd < 0) {
                    var l = Math.sqrt(x * x + y * y);
                    var m = masses[data.index] / (mass + masses[data.index]);

                    if (l > 0.000001) {
                        if (Math.abs(xd) < Math.abs(yd)) {
                            node.vx -= (x *= xd / l * strength) * m;
                            data.vx += x * (1 - m);
                        } else {
                            node.vy -= (y *= yd / l * strength) * m;
                            data.vy += y * (1 - m);
                        }
                    }
                }
            }

            return x0 > xi + xSize || y0 > yi + ySize ||
                x1 < xi - xSize || y1 < yi - ySize;
        }

        function prepare(quad) {
            if (quad.data) {
                quad.size = sizes[quad.data.index];
            } else {
                quad.size = [0, 0];
                var i = -1;
                while (++i < 4) {
                    if (quad[i] && quad[i].size) {
                        quad.size[0] = Math.max(quad.size[0], quad[i].size[0]);
                        quad.size[1] = Math.max(quad.size[1], quad[i].size[1]);
                    }
                }
            }
        }
    }

    function xCenter(d) { return d.x + d.vx + sizes[d.index][0] / 2; }
    function yCenter(d) { return d.y + d.vy + sizes[d.index][1] / 2; }

    force.initialize = function (_) {
        sizes = (nodes = _).map(size);
        masses = sizes.map(function (d) { return d[0] * d[1] });
    }

    force.size = function (_) {
        return (arguments.length
            ? (size = typeof _ === 'function' ? _ : constant(_), force)
            : size);
    }

    force.strength = function (_) {
        return (arguments.length ? (strength = +_, force) : strength);
    }

    force.iterations = function (_) {
        return (arguments.length ? (iterations = +_, force) : iterations);
    }

    return force;
}

function boundedBox() {
    var nodes, sizes;
    var bounds;
    var size = constant([0, 0]);

    function force() {
        var node, size;
        var xi, x0, x1, yi, y0, y1;
        var i = -1;
        while (++i < nodes.length) {
            node = nodes[i];
            size = sizes[i];
            xi = node.x + node.vx;
            x0 = bounds[0][0] - (xi - size[0]/2);
            x1 = bounds[1][0] - (xi + size[0]/2);
            yi = node.y + node.vy;
            y0 = bounds[0][1] - (yi - size[1]/2);
            y1 = bounds[1][1] - (yi + size[1]/2);
            if (x0 > 0 || x1 < 0) {
                node.x += node.vx;
                node.vx = -node.vx;
                if (node.vx < x0) { node.x += x0 - node.vx; }
                if (node.vx > x1) { node.x += x1 - node.vx; }
            }
            if (y0 > 0 || y1 < 0) {
                node.y += node.vy;
                node.vy = -node.vy;
                if (node.vy < y0) { node.vy += y0 - node.vy; }
                if (node.vy > y1) { node.vy += y1 - node.vy; }
            }
        }
    }

    force.initialize = function (_) {
        sizes = (nodes = _).map(size);
    }

    force.bounds = function (_) {
        return (arguments.length ? (bounds = _, force) : bounds);
    }

    force.size = function (_) {
        return (arguments.length
            ? (size = typeof _ === 'function' ? _ : constant(_), force)
            : size);
    }

    return force;
}


function constant(_) {
    return function () { return _; }
}

</script>
</body>
</html>
